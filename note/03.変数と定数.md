**TypeScript
データ型を明示してすること**
```
const foo: string = "abc";
```

型注釈がなくても”型”推測して決めてくること
```
const foo = "abc"; //文字列推測
foo = 100; //compile error
```
---

### 1. `var`

* **再代入（賦值）**：✅ 可以
* **再宣言（重新宣告）**：✅ 可以
* **作用域**：函數作用域（function scope）
* **解釋**：

  * 在函數內使用 `var` 宣告的變數，只要還在同一個函數裡就能存取。
  * 但它 **不具備區塊作用域**，例如在 `if` 或 `for` 區塊裡宣告的 `var`，外面依然能取到。
  * 容易導致意料之外的覆蓋或 bug，因此在 TS 開發中 **幾乎不建議使用 `var`**。

```ts
if (true) {
  var x = 1;
}
console.log(x); // 1 ✅ 還能取到
```

---

### 2. `let`

* **再代入**：✅ 可以
* **再宣言**：❌ 不可以
* **作用域**：區塊作用域（block scope）
* **解釋**：

  * 在 `if`、`for`、`{ }` 區塊中宣告的變數，只能在該區塊內使用。
  * 避免了 `var` 的「外洩」問題。
  * TypeScript 預設開發時，會建議用 `let` 取代 `var`。

```ts
if (true) {
  let y = 2;
}
console.log(y); // ❌ 錯誤，y 在區塊外不可存取
```

---

### 3. `const`

* **再代入**：❌ 不可以
* **再宣言**：❌ 不可以
* **作用域**：區塊作用域（block scope）
* **解釋**：

  * 宣告時必須同時初始化（指定值），之後不能重新賦值。
  * 適合用於常數、或不會被重新指派的變數。
  * 但注意：**const 不能變更指向，但可以修改物件內容**。

```ts
const z = 3;
z = 4; // ❌ 錯誤：不能重新賦值

const obj = { a: 1 };
obj.a = 2; // ✅ 可以修改物件屬性
```

---

✅ **總結（TS 建議用法）**：

* **`var`**：避免使用。
* **`let`**：用於需要重新賦值的變數。
* **`const`**：用於固定不會變更引用的變數，實務上 **優先使用 `const`，若需要才退一步用 `let`**。

---
**例子**
```
// 飼っているペットを出力する関数
function myPet() {
  if (true) {
    var dog = "はすきー"; // 狗
    let cat = "しゃむ";   // 貓

    console.log(`犬: ${dog} 猫: ${cat}`);
  }

  console.log(`犬: ${dog} 猫: ${cat}`);
}
```
**輸出結果**
```
第一次 console.log（在 if 區塊內）

var dog = "哈士奇"; → 因為 var 是 函數作用域，所以 dog 在整個 myPet 函數內都能使用。

let cat = "暹羅貓"; → 因為 let 是 區塊作用域，所以 cat 只在 if 區塊內有效。

輸出結果：

狗: 哈士奇 貓: 暹羅貓


第二次 console.log（在 if 區塊外）

dog 還能取到，因為 var 屬於函數作用域。

cat 取不到，因為 let 限定在 if 區塊內，外面已經失效。

結果會拋錯誤：

ReferenceError: cat is not defined
```
---
